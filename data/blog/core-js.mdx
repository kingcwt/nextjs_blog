---
title: javaScript基础题
date: '2018-07-25'
tags: ['javaScript','interview']
draft: false
coverImg: '/static/images/react-core.jpg'
summary: '记录一些基础的js题'
---

## 下面代码输出什么？

```js
for (var i = 0; i < 3; i++) {
  setTimeout(function log() {
    console.log(i)
  }, 1000)
}

// 333
```
使用var声明的i是函数作用域的，它在整个函数中都是可见的，而不仅仅在for循环内，这意味着只有一个i变量，而不是每次创建新的变量，每次执行都设置啦一个定时器，但定时器并没有立即执行，然后
等到执行的时候，外部的i已经是3啦。所以三次打印输出的结果都是3，如果想输出0，1，2 可以直接使用let声明块级作用域。也可以包裹一个只执行函数。


## 下列关于vite实现原理。不正确的是？
- [ ] A esbuild使用go这样语言编写，cpu密集下更具性能优势，编译速度更快
- [ ] B 充分利用http缓存做优化，依赖（不会变动的代码）部分用max-age,immutable 强缓存
- [ ] C 服务器接收到的所有请求都会编译对应的文件，并将ESM源码返回给浏览器
- [ ] D 在预构建阶段將依赖中各种其他機续化规范（CommonJS、UM) 换 成ESM，以提供给浏览器

<HiddenContent>
 答案：**C**

 > 详细解释：

 **A选项**：

 esbuild 确实是用 Go 语言编写的,
 在 CPU 密集型任务中，esbuild 通常比用 JavaScript 编写的打包工具（如 webpack）具有性能优势
 esbuild 的编译速度确实非常快，是其主要优势之一。

**B选项**：

1 Vite确实充分利用了HTTP缓存来优化性能。
2 对于依赖（node_modules 中的代码），这些通常是不会频繁变动的，Vite 会：
   - 使用强缓存策略
   - 在响应头中设置 max-age=31536000,immutable
   - max-age=31536000 表示缓存一年
   - immutable 表示该资源永远不会改变
3 这种策略确保了依赖不会被频繁请求，大大提高了加载速度。
4 当依赖更新时，Vite 会使用带有 hash 的 URL，确保获取新版本。

**C选项**：

这个说法是不正确的,
1 Vite 的一个核心特性是利用浏览器原生的 ES 模块支持，它并不会对所有请求的文件都进行编译。
2 Vite 的处理方式如下:
  - 对于 JavaScript 文件，Vite 通常只进行简单的路径重写和预处理，而不是完全编译。它会将文件以 ESM 格式直接返回给浏览器。
  - 对于非 JavaScript 资源（如 CSS、Vue 单文件组件等），Vite 会进行必要的转换，以使浏览器能够正确解析。
  - 对于第三方依赖，Vite 会在首次请求时进行预构建，之后直接从缓存中提供。
3 Vite 采用按需编译的策略，只有在浏览器实际请求某个模块时，才会对该模块进行处理。
4 在开发模式下，Vite 会尽可能保持源代码的原样，以便于调试。
因此，说"所有请求都会编译对应的文件"是不准确的。Vite 的处理方式更加灵活和高效，根据不同类型的文件和请求采取不同的策略。

**D选项**：

1 Vite 确实在预构建阶段会处理项目依赖。
2 预构建的主要目的之一就是将非 ESM 格式的依赖转换为 ESM 格式。这包括：
  - 将 CommonJS 模块转换为 ESM
  - 将 UMD (Universal Module Definition) 模块转换为 ESM
3 这个过程是必要的，因为：
  - 浏览器原生支持 ESM，但不直接支持 CommonJS 或 UMD
  - 许多 npm 包仍然使用 CommonJS 或 UMD 格式发布
4 预构建还有其他好处：
  - 减少浏览器请求数量（通过打包共同依赖）
  - 提高加载性能
5 Vite 使用 esbuild 来执行这个预构建过程，这使得预构建非常快速。
因此，这个描述准确地反映了 Vite 预构建阶段的一个重要功能。这个策略使得 Vite 能够充分利用浏览器的原生 ESM 支持，同时又保持了与现有 npm 生态系统的兼容性。

</HiddenContent>

