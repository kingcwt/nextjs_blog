---
title: React interview Base
date: '2024-9-20'
tags: ['react','interview']
draft: false
coverImg: '/static/images/react-core.jpg'
summary: '自己做的一些题，巩固自己的react知识。查漏补缺，附带答案 😝 (日常更新)'
---
<TOCInline toc={props.toc} exclude="Introduction" />

## 下面代码输出什么？

```js
for (var i = 0; i < 3; i++) {
  setTimeout(function log() {
    console.log(i)
  }, 1000)
}

```
<HiddenContent>
答案: **333**

使用var声明的i是函数作用域的，它在整个函数中都是可见的，而不仅仅在for循环内，这意味着只有一个i变量，而不是每次创建新的变量，每次执行都设置啦一个定时器，但定时器并没有立即执行，然后
等到执行的时候，外部的i已经是3啦。所以三次打印输出的结果都是3，如果想输出0，1，2 可以直接使用let声明块级作用域。也可以包裹一个自执行函数。
</HiddenContent>


## 下列关于vite实现原理。不正确的是？
- [ ] A esbuild使用go这样语言编写，cpu密集下更具性能优势，编译速度更快
- [ ] B 充分利用http缓存做优化，依赖（不会变动的代码）部分用max-age,immutable 强缓存
- [ ] C 服务器接收到的所有请求都会编译对应的文件，并将ESM源码返回给浏览器
- [ ] D 在预构建阶段將依赖中各种其他機续化规范（CommonJS、UM) 换 成ESM，以提供给浏览器

<HiddenContent>
 答案：**C**

 > 详细解释：

 **A选项**：

 esbuild 确实是用 Go 语言编写的,
 在 CPU 密集型任务中，esbuild 通常比用 JavaScript 编写的打包工具（如 webpack）具有性能优势
 esbuild 的编译速度确实非常快，是其主要优势之一。

**B选项**：

1 Vite确实充分利用了HTTP缓存来优化性能。

2 对于依赖（node_modules 中的代码），这些通常是不会频繁变动的，Vite 会：
   - 使用强缓存策略
   - 在响应头中设置 max-age=31536000,immutable
   - max-age=31536000 表示缓存一年
   - immutable 表示该资源永远不会改变
3 这种策略确保了依赖不会被频繁请求，大大提高了加载速度。
4 当依赖更新时，Vite 会使用带有 hash 的 URL，确保获取新版本。

**C选项**：

这个说法是不正确的

1 Vite 的一个核心特性是利用浏览器原生的 ES 模块支持，它并不会对所有请求的文件都进行编译。

2 Vite 的处理方式如下:
  - 对于 JavaScript 文件，Vite 通常只进行简单的路径重写和预处理，而不是完全编译。它会将文件以 ESM 格式直接返回给浏览器。
  - 对于非 JavaScript 资源（如 CSS、Vue 单文件组件等），Vite 会进行必要的转换，以使浏览器能够正确解析。
  - 对于第三方依赖，Vite 会在首次请求时进行预构建，之后直接从缓存中提供。

3 Vite 采用按需编译的策略，只有在浏览器实际请求某个模块时，才会对该模块进行处理。

4 在开发模式下，Vite 会尽可能保持源代码的原样，以便于调试。

因此，说"所有请求都会编译对应的文件"是不准确的。Vite 的处理方式更加灵活和高效，根据不同类型的文件和请求采取不同的策略。

**D选项**：

1 Vite 确实在预构建阶段会处理项目依赖。

2 预构建的主要目的之一就是将非 ESM 格式的依赖转换为 ESM 格式。这包括：
  - 将 CommonJS 模块转换为 ESM
  - 将 UMD (Universal Module Definition) 模块转换为 ESM

3 这个过程是必要的，因为：
  - 浏览器原生支持 ESM，但不直接支持 CommonJS 或 UMD
  - 许多 npm 包仍然使用 CommonJS 或 UMD 格式发布

4 预构建还有其他好处：
  - 减少浏览器请求数量（通过打包共同依赖）
  - 提高加载性能
5 Vite 使用 esbuild 来执行这个预构建过程，这使得预构建非常快速。
因此，这个描述准确地反映了 Vite 预构建阶段的一个重要功能。这个策略使得 Vite 能够充分利用浏览器的原生 ESM 支持，同时又保持了与现有 npm 生态系统的兼容性。

</HiddenContent>


## 关于react中的diff算法，下面说法不正确的是？

- [ ] A 时间复杂度能达到O(1)
- [ ] B 会帮助我们计算出 Virtual DOM 中真正发生变化的部分
- [ ] C 两棵树只对同一层级节点进行比较，只要该节点不存在了，那么该节点与其所有子节点会被完全删除，不在进行进一步比较
- [ ] D 只需要遍历一次，便完成对整个DOM树的比较

<HiddenContent>
答案：**D**

> **背景知识**：
>
> React使用Virtual DOM(虚拟DOM)技术来提升性能。所谓Virtual DOM,就是React用JS对象的形式来表示真实的DOM树结构。当应用状态发生变化时，React会重新构建
> 一棵新的Virtual DOM树，并将其与之前的旧Virtual DOM树进行对比，找出发生变化的部分，最后只将有差异的部分更新到真实的DOM中。
>
> 这个过程中的对比(或称为"diff")就是React的diff算法。diff算法的效率至关重要，因为直接操作真实DOM的代价是昂贵的，尤其是当前页面元素较多时，性能会受到很大影响。

-----

> 详细解释

**A选项**

 - 这个说法是正确的。React的diff算法通过一些优化策略，如同层比较、key值比较等，将时间复杂度从O(n^3)降低到了O(n)。在某些情况下，如只有少量节点变化时，可以接近O(1)的时间复杂度。

**B选项**

解释:
 - 这是React diff算法的核心功能之一，React通过比较新旧两棵Virtual DOM树，来确定那部分发生了变化，并最终更新这些变化的部分。

具体过程：

**1 对比新旧Virtual DOM:** 当应用状态改变时，React首先会重新构建一棵新的Virtual DOM树，然后，React会将这棵新的Virtual DOM与之前的旧Virtual DOM进行比较

**2 找出不同的地方** React使用diff算法来逐层比较新旧Virtual DOM树的节点，找出发生变化的部分

**3 最小化真实DOM操作** 基于diff算法的结果，React只会更新那些真正发生变化的部分，而不会重新渲染整个DOM。这是React性能优化的关键所在

**C选项**

 - 两棵树只对同一层级节点进行比较，只要该节点不存在了，那么该节点与其所有子节点会被完全删除，不再进行进一步比较：
   这个说法是正确的。React的diff算法采用了同层比较的策略，如果某个节点在新的树中不存在，则该节点及其所有子节点都会被删除，不会继续比较子节点，这样可以大大提高比较效率。

**D选项**

 - 只需要遍历一次，便完成对整个DOM树的比较：
 这个说法是不正确的。React的diff算法虽然高效，但并不是只遍历一次就能完成整个DOM树的比较。实际上，diff算法需要遍历新旧两棵虚拟DOM树，比较各个节点的差异。这个过程可能需要多次遍历，特别是在处理列表和子组件时

因此，D选项是不正确的说法，而其他选项都是正确的。

</ HiddenContent>

## 在react中，各组件之间是如何通信的？【多选】
- [ ] A.兄弟：两个组件并列存在于父组件中，需要金属数据进行相互传递
- [ ] B.父与子：父组件包裹子组件，父组件向子组件传递数据
- [ ] C. 无直接关系：两个组件并没有直接的关联关系，处在一棵树中相距甚远的位置，但需要共享、传递数据
- [ ] D.子与父：子组件存在于父组件之中，子组件需要向父组件传递数据

<HiddenContent>
答案： **B,C,D**

> **B. 父与子：父组件包裹子组件，父组件向子组件传递数据**

这是正确的。在React中，父组件可以通过props向子组件传递数据，这是一种常见的数据流动方式。

> **C. 无直接关系：两个组件并没有直接的关联关系，处在一棵树中相距甚远的位置，但需要共享、传递数据**

这也是正确的。React中的Context API就是为了解决这种情况而设计的。它允许在组件树中共享数据，而不必显式地通过每层组件传递props。

> **D. 子与父：子组件存在于父组件之中，子组件需要向父组件传递数据**

这同样是正确的。在React中，子组件可以通过回调函数向父组件传递数据。父组件将一个函数作为prop传给子组件，子组件在需要时调用这个函数并传入数据。

> **A. 兄弟：两个组件并列存在于父组件中，需要金属数据进行相互传递**

这个选项是不正确的。兄弟组件之间不能直接传递数据，通常需要通过它们共同的父组件来实现数据传递，或者使用状态管理库如Redux。

</HiddenContent>


## 关于函数组件和类组件的说法，正确的是? 【多选】

- [ ] A. 可以为类组件定义ref属性
- [ ] B. 函数组件具有生命周期方法
- [ ] C. 一个函数组件接收props作力参数，返回代表这个组件UI的React元素结构
- [ ] D. 可以为函数组件定义ref属性

<HiddenContent>
答案：**A,C**

- A 选项正确，因为类组件可以定义 ref 属性，用于访问组件实例。

- C 选项正确，函数组件确实接收 props 作为参数并返回代表 UI 的 React 元素。

- B 选项错误，函数组件没有生命周期方法，但可以通过 Hooks 模拟。

- D 选项错误，函数组件无法直接定义 ref，需要通过 forwardRef 才能实现。
</HiddenContent>