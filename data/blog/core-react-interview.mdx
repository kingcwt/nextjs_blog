---
title: React interview Base
date: '2024-9-20'
tags: ['react','interview']
draft: false
coverImg: '/static/images/react-core.jpg'
summary: '自己做的一些题，巩固自己的react知识。查漏补缺，附带答案 😝 (日常更新)'
---
<TOCInline toc={props.toc} exclude="Introduction" />

## 下面代码输出什么？

```js
for (var i = 0; i < 3; i++) {
  setTimeout(function log() {
    console.log(i)
  }, 1000)
}

```
<HiddenContent>
答案: **333**

使用var声明的i是函数作用域的，它在整个函数中都是可见的，而不仅仅在for循环内，这意味着只有一个i变量，而不是每次创建新的变量，每次执行都设置啦一个定时器，但定时器并没有立即执行，然后
等到执行的时候，外部的i已经是3啦。所以三次打印输出的结果都是3，如果想输出0，1，2 可以直接使用let声明块级作用域。也可以包裹一个自执行函数。
</HiddenContent>


## 下列关于vite实现原理。不正确的是？
- [ ] A esbuild使用go这样语言编写，cpu密集下更具性能优势，编译速度更快
- [ ] B 充分利用http缓存做优化，依赖（不会变动的代码）部分用max-age,immutable 强缓存
- [ ] C 服务器接收到的所有请求都会编译对应的文件，并将ESM源码返回给浏览器
- [ ] D 在预构建阶段將依赖中各种其他機续化规范（CommonJS、UM) 换 成ESM，以提供给浏览器

<HiddenContent>
 答案：**C**

 > 详细解释：

 **A选项**：

 esbuild 确实是用 Go 语言编写的,
 在 CPU 密集型任务中，esbuild 通常比用 JavaScript 编写的打包工具（如 webpack）具有性能优势
 esbuild 的编译速度确实非常快，是其主要优势之一。

**B选项**：

1 Vite确实充分利用了HTTP缓存来优化性能。

2 对于依赖（node_modules 中的代码），这些通常是不会频繁变动的，Vite 会：
   - 使用强缓存策略
   - 在响应头中设置 max-age=31536000,immutable
   - max-age=31536000 表示缓存一年
   - immutable 表示该资源永远不会改变
3 这种策略确保了依赖不会被频繁请求，大大提高了加载速度。
4 当依赖更新时，Vite 会使用带有 hash 的 URL，确保获取新版本。

**C选项**：

这个说法是不正确的

1 Vite 的一个核心特性是利用浏览器原生的 ES 模块支持，它并不会对所有请求的文件都进行编译。

2 Vite 的处理方式如下:
  - 对于 JavaScript 文件，Vite 通常只进行简单的路径重写和预处理，而不是完全编译。它会将文件以 ESM 格式直接返回给浏览器。
  - 对于非 JavaScript 资源（如 CSS、Vue 单文件组件等），Vite 会进行必要的转换，以使浏览器能够正确解析。
  - 对于第三方依赖，Vite 会在首次请求时进行预构建，之后直接从缓存中提供。

3 Vite 采用按需编译的策略，只有在浏览器实际请求某个模块时，才会对该模块进行处理。

4 在开发模式下，Vite 会尽可能保持源代码的原样，以便于调试。

因此，说"所有请求都会编译对应的文件"是不准确的。Vite 的处理方式更加灵活和高效，根据不同类型的文件和请求采取不同的策略。

**D选项**：

1 Vite 确实在预构建阶段会处理项目依赖。

2 预构建的主要目的之一就是将非 ESM 格式的依赖转换为 ESM 格式。这包括：
  - 将 CommonJS 模块转换为 ESM
  - 将 UMD (Universal Module Definition) 模块转换为 ESM

3 这个过程是必要的，因为：
  - 浏览器原生支持 ESM，但不直接支持 CommonJS 或 UMD
  - 许多 npm 包仍然使用 CommonJS 或 UMD 格式发布

4 预构建还有其他好处：
  - 减少浏览器请求数量（通过打包共同依赖）
  - 提高加载性能
5 Vite 使用 esbuild 来执行这个预构建过程，这使得预构建非常快速。
因此，这个描述准确地反映了 Vite 预构建阶段的一个重要功能。这个策略使得 Vite 能够充分利用浏览器的原生 ESM 支持，同时又保持了与现有 npm 生态系统的兼容性。

</HiddenContent>


## 关于react中的diff算法，下面说法不正确的是？

- [ ] A 时间复杂度能达到O(1)
- [ ] B 会帮助我们计算出 Virtual DOM 中真正发生变化的部分
- [ ] C 两棵树只对同一层级节点进行比较，只要该节点不存在了，那么该节点与其所有子节点会被完全删除，不在进行进一步比较
- [ ] D 只需要遍历一次，便完成对整个DOM树的比较

<HiddenContent>
答案：**D**

> **背景知识**：
>
> React使用Virtual DOM(虚拟DOM)技术来提升性能。所谓Virtual DOM,就是React用JS对象的形式来表示真实的DOM树结构。当应用状态发生变化时，React会重新构建
> 一棵新的Virtual DOM树，并将其与之前的旧Virtual DOM树进行对比，找出发生变化的部分，最后只将有差异的部分更新到真实的DOM中。
>
> 这个过程中的对比(或称为"diff")就是React的diff算法。diff算法的效率至关重要，因为直接操作真实DOM的代价是昂贵的，尤其是当前页面元素较多时，性能会受到很大影响。

-----

> 详细解释

**A选项**

 - 这个说法是正确的。React的diff算法通过一些优化策略，如同层比较、key值比较等，将时间复杂度从O(n^3)降低到了O(n)。在某些情况下，如只有少量节点变化时，可以接近O(1)的时间复杂度。

**B选项**

解释:
 - 这是React diff算法的核心功能之一，React通过比较新旧两棵Virtual DOM树，来确定那部分发生了变化，并最终更新这些变化的部分。

具体过程：

**1 对比新旧Virtual DOM:** 当应用状态改变时，React首先会重新构建一棵新的Virtual DOM树，然后，React会将这棵新的Virtual DOM与之前的旧Virtual DOM进行比较

**2 找出不同的地方** React使用diff算法来逐层比较新旧Virtual DOM树的节点，找出发生变化的部分

**3 最小化真实DOM操作** 基于diff算法的结果，React只会更新那些真正发生变化的部分，而不会重新渲染整个DOM。这是React性能优化的关键所在

**C选项**

 - 两棵树只对同一层级节点进行比较，只要该节点不存在了，那么该节点与其所有子节点会被完全删除，不再进行进一步比较：
   这个说法是正确的。React的diff算法采用了同层比较的策略，如果某个节点在新的树中不存在，则该节点及其所有子节点都会被删除，不会继续比较子节点，这样可以大大提高比较效率。

**D选项**

 - 只需要遍历一次，便完成对整个DOM树的比较：
 这个说法是不正确的。React的diff算法虽然高效，但并不是只遍历一次就能完成整个DOM树的比较。实际上，diff算法需要遍历新旧两棵虚拟DOM树，比较各个节点的差异。这个过程可能需要多次遍历，特别是在处理列表和子组件时

因此，D选项是不正确的说法，而其他选项都是正确的。

</ HiddenContent>

## 在react中，各组件之间是如何通信的？【多选】
- [ ] A.兄弟：两个组件并列存在于父组件中，需要金属数据进行相互传递
- [ ] B.父与子：父组件包裹子组件，父组件向子组件传递数据
- [ ] C. 无直接关系：两个组件并没有直接的关联关系，处在一棵树中相距甚远的位置，但需要共享、传递数据
- [ ] D.子与父：子组件存在于父组件之中，子组件需要向父组件传递数据

<HiddenContent>
答案： **B,C,D**

> **B. 父与子：父组件包裹子组件，父组件向子组件传递数据**

这是正确的。在React中，父组件可以通过props向子组件传递数据，这是一种常见的数据流动方式。

> **C. 无直接关系：两个组件并没有直接的关联关系，处在一棵树中相距甚远的位置，但需要共享、传递数据**

这也是正确的。React中的Context API就是为了解决这种情况而设计的。它允许在组件树中共享数据，而不必显式地通过每层组件传递props。

> **D. 子与父：子组件存在于父组件之中，子组件需要向父组件传递数据**

这同样是正确的。在React中，子组件可以通过回调函数向父组件传递数据。父组件将一个函数作为prop传给子组件，子组件在需要时调用这个函数并传入数据。

> **A. 兄弟：两个组件并列存在于父组件中，需要金属数据进行相互传递**

这个选项是不正确的。兄弟组件之间不能直接传递数据，通常需要通过它们共同的父组件来实现数据传递，或者使用状态管理库如Redux。

</HiddenContent>


## 关于函数组件和类组件的说法，正确的是? 【多选】

- [ ] A. 可以为类组件定义ref属性
- [ ] B. 函数组件具有生命周期方法
- [ ] C. 一个函数组件接收props作力参数，返回代表这个组件UI的React元素结构
- [ ] D. 可以为函数组件定义ref属性

<HiddenContent>
答案：**A,C**

- A 选项正确，因为类组件可以定义 ref 属性，用于访问组件实例。

- C 选项正确，函数组件确实接收 props 作为参数并返回代表 UI 的 React 元素。

- B 选项错误，函数组件没有生命周期方法，但可以通过 Hooks 模拟。

- D 选项错误，函数组件无法直接定义 ref，需要通过 forwardRef 才能实现。
</HiddenContent>


## 关于useEffect(callback,[source]),下面说法错误的是【单选】

- [ ] A. [source] 参数传口时，外部的函数只会在初始化时调用一次，返回的那个函数也只会最终在组件卸载时调用一次
- [ ] B. [source] 参数有值时，只会监听到数组中的值发生变化后才优先调用返回的那个函数，再调用外部的函数
- [ ] C. callback是一个函数，是组件要执行的副作用，可以不传
- [ ] D. [source] 可以不传

<HiddenContent>
 答案: **C**

> 选项 A: [source] 参数传 [] 时，外部的函数只会在初始化时调用一次，返回的那个函数也只会最终在组件卸载时调用一次

当 useEffect 的依赖数组是空数组 [] 时，callback 函数只会在组件首次渲染时执行一次，而不会在后续的更新中执行。同时，callback 返回的清理函数会在组件卸载时调用一次，这用于清除副作用。

例如：
```jsx
useEffect(() => {
  console.log("Component mounted");
  return () => {
    console.log("Component unmounted");
  };
}, []);
```
因此，A 选项是正确的。

> 选项 B: [source] 参数有值时，只会监听到数组中的值发生变化后才优先调用返回的那个函数，再调用外部的函数

当 useEffect 的依赖数组中有值时，React 会在这些依赖的值发生变化时先执行上一个 callback 的清理函数（如果有），然后执行新的 callback 函数。这是为了确保在新的副作用执行之前，之前的副作用得以清理。

例如：
```jsx
useEffect(() => {
  console.log("Effect executed");
  return () => {
    console.log("Effect cleaned up");
  };
}, [someValue]);
```
当 someValue 发生变化时，首先会调用上一个 callback 返回的清理函数，接着再执行新的副作用函数。因此，B 选项是正确的。

> 选项 C: callback 是一个函数，是组件要执行的副作用，可以不传

useEffect 的第一个参数 callback 是一个必传的副作用函数，用于在组件的生命周期中特定时机执行副作用操作（例如数据请求、事件监听等）。如果不传递这个 callback，useEffect 将无法正确执行

如果 callback 不传，useEffect 将报错，因此，C 选项是错误的，因为 callback 不能不传。

> 选项 D: [source] 可以不传

useEffect 的第二个参数 [source] 是可选的。如果不传递这个参数，useEffect 会在每次组件更新时执行，即在每一次渲染后都会执行 callback。
所以，D 选项是正确的。

</HiddenContent>

## 下列哪些做法不能对vue的性能进行优化 【单选】

- [ ] A.扁平化Store数据结构，合理使用持久化Store数据
- [ ] B. 合理地组织代码结构
- [ ] C. 为item设置唯一key值
- [ ] D. 内容类系统的图片资源按需加载（v-lazy、滚动到可视区域加载等）

<HiddenContent>
答案：**B**
> 选项 A: 扁平化 Store 数据结构，合理使用持久化 Store 数据

扁平化 Store 数据结构确实可以减少深层嵌套的读取复杂性，从而提高访问效率。此外，合理使用持久化 Store 数据可以避免重复获取数据，提高性能。因此，A 选项是可以优化性能的。

> 选项 B: 合理地组织代码结构

合理的代码结构能够帮助降低维护成本，并减少重复逻辑，从而优化性能。对组件和功能模块进行合适的拆分与封装也是性能优化的一部分。因此，B 选项也是可以优化性能的。

> 选项 C: 为 item 设置唯一 key 值

为 v-for 列表渲染的每个 item 设置唯一的 key 值，是帮助 Vue 在更新时有效追踪元素和最小化 DOM 操作的关键手段。如果不使用唯一的 key，可能会导致列表渲染时出现性能问题。因此，C 选项是有助于优化性能的

> 选项 D: 内容类系统的图片资源按需加载（v-lazy、滚动到可视区域加载等）

懒加载图片资源（如使用 v-lazy 指令）是在 Vue 应用中进行性能优化的常见手段，特别适合内容较多的页面，能够减少初次渲染时的网络开销。因此，D 选项是优化性能的手段。

**四个选项中，B 选项 “合理地组织代码结构” 是一个广义上的编码习惯，并不会直接影响 Vue 的性能。它更多是从代码清晰度和可维护性的角度考虑，并不涉及 Vue 性能上的优化。因此，B 选项不能直接优化 Vue 的性能。**

</HiddenContent>

## 关于 HTTP Cookie，下面说法不正确的是 【单选】

- [ ] A. Cookie 以加密的形式在浏览器和服务器中传递
- [ ] B. Cookie 的有效期可以通过 Expires 和Max-Age 两个属性来设置
- [ ] C. Cookie 主要用于会话状态管理，个性化设置，浏览器行为跟踪等方面
- [ ] D. Cookie 本质上就是浏览器里面存储的一个很小的文本文件，内部以键值对的方式来存储

<HiddenContent>
答案: **A**

> 选项 A: Cookie 以加密的形式在浏览器和服务器中传递

这个说法是不准确的。Cookie 本身并不会默认以加密形式传递，除非在传输过程中使用了 HTTPS 协议，这样可以确保 Cookie 在传输过程中是加密的。如果使用 HTTP 协议，Cookie 在网络中是明文传输的。所以，如果要确保 Cookie 的安全性，需要结合 HTTPS 或手动加密 Cookie 的内容。因此，A 选项是不正确的。

> 选项 B: Cookie 的有效期可以通过 Expires 和 Max-Age 两个属性来设置

这句话是正确的。Cookie 的过期时间可以通过 Expires 或 Max-Age 属性来设置

 - Expires: 设置一个具体的日期时间，当到达这个时间点时，Cookie 会被浏览器删除

 - Max-Age: 设置 Cookie 的有效时长（以秒为单位），当这个时长过了之后，Cookie 会被删除。

因此，B 选项是正确的。

> 选项 C: Cookie 主要用于会话状态管理、个性化设置、浏览器行为跟踪等方面

这个说法是正确的。Cookie 经常用于会话管理（例如保持用户登录状态），也用于个性化设置（例如存储用户的偏好），以及广告或分析用途中的用户行为跟踪。因此，C 选项是正确的。

> 选项 D: Cookie 本质上就是浏览器里面存储的一个很小的文本文件，内部以键值对的方式来存储

这句话也是正确的。Cookie 本质上就是存储在浏览器中的一个小文本数据，以键值对的方式存储一些信息，用于 HTTP 请求时与服务器通信。单个 Cookie 的大小限制通常在 4KB 左右，主要存储小量的信息。

**A 选项是不正确的，因为 Cookie 本身并不是加密传输的，是否加密取决于是否使用了 HTTPS**
</HiddenContent>


## 关于react高阶组件（HOC），下面说法正确的是 【单选】

- [ ] A. HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式
- [ ] B. HOC传递给被包裹组件的props容易和被包裹后的组件重名，进而被覆盖
- [ ] C. HOC可以复用逻辑，不影响被包裹组件的内部逻辑
- [ ] D.高阶组件可以传递所有的props，但是不能传递ref

<HiddenContent>
答案：**A**

> 选项 A: HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式

高阶组件确实不是 React 的原生 API，而是一种设计模式，用来复用组件逻辑。HOC 本质上是一个函数，接受一个组件作为参数并返回一个新组件。它是利用 React 的组合特性而设计的。

**因此，A 选项是正确的。**

> 选项 B: HOC 传递给被包裹组件的 props 容易和被包裹后的组件重名，进而被覆盖

这句话有误。HOC 传递的 props 一般不会与被包裹组件的 props 冲突，因为 HOC 通常会直接传递所有 props 给被包裹的组件，即 ...props。如果 HOC 覆盖了某些 props，那是开发者有意为之，并不会“容易”发生这种情况。

**B 选项是错误的。**

> 选项 C: HOC 可以复用逻辑，不影响被包裹组件的内部逻辑

虽然高阶组件的主要作用是复用逻辑，但这个说法有些含糊。HOC 的确可以复用逻辑，但并不能保证它完全不影响被包裹组件的内部逻辑。在某些情况下，HOC 的引入可能会对被包裹组件的行为产生影响，尤其是在 props 或生命周期方法的处理上。因此，说 “不影响内部逻辑” 并不完全准确。

**C 选项是不准确的。**

> 选项 D: 高阶组件可以传递所有的 props，但是不能传递 ref

这个说法是不准确的。虽然默认情况下 ref 是不能通过 HOC 直接传递的，但可以通过 React.forwardRef 解决这个问题。因此，HOC 是可以传递 ref 的，只需要特殊处理。因此，这个说法并不完全正确。

**所以，D 选项是不正确的。**


</HiddenContent>